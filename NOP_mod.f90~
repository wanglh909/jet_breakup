module NOP_mod
  use kind

  implicit none
  integer(kind=ik):: i, j, NEX, NEY, NNX, NTN, NTE, NVar, iBW       !NVar: Number of Variables   !NNX: number of nodes in r (abscissa)
  integer(kind=ik):: LNVar = 5    !LNVar: local number of variable (r,z,u,v,p --> 5)
  integer(kind=ik):: timestep, step
  integer(kind=ik), allocatable:: MDF(:), NOPP(:)
  integer(kind=ik):: LMDF(9), LNOPP(9)
  integer(kind=ik):: rowN, columnN, globalN
  real(kind=rk):: R, H, time
  integer(kind=ik), allocatable:: globalNM(:,:), rowNM(:), columnNM(:)
  real(kind=rk), allocatable:: rcoordinate(:), zcoordinate(:), usol(:), vsol(:), psol(:)

  real(kind=rk), parameter, dimension(3):: gausspoint = (/0.5d0*(-0.7745966692414833770358531d0 + 1.0d0),&
       0.5d0*(0.000000000000000000000000000000d0 + 1.0d0),0.5d0*(0.7745966692414833770358531d0 + 1.0d0)/)



  !for subroutine basis_function
  real(kind=rk):: phi(3,3,9), phisi(3,3,9), phieta(3,3,9), psi(3,3,9), psisi(3,3,9), psieta(3,3,9), &
       phi_1d(3,3), phix_1d(3,3)
  integer(kind=ik),parameter:: convert49(4) = (/1, 3, 7, 9/)




  !for subroutine prediction
  real(kind=rk), allocatable:: sol(:), solp(:), soldot(:), soldotp(:), soldotpp(:), solpred(:)
  !solp & dtp means previous solution & dt, solpred means the predicted solution
  real(kind=rk):: dt, dtp, CTJ, change, trunerr
  real(kind=rk), parameter:: eps = 1.0d-3



  !for subroutine values_in_an_element
  integer(kind=ik):: m, k, l, n, npp
  real(kind=rk):: rlocal(9), zlocal(9), ulocal(9), vlocal(9), plocal(9)
  integer(kind=ik), parameter:: Nr = 0, Nz = 1, Nu = 2, Nv = 3, Np = 4
  integer(kind=ik), parameter:: NNr = 1, NNz = 2, NNu = 3, NNv = 4, NNp = 5
  real(kind=rk):: rintfac(3,3), rsi(3,3), reta(3,3), zsi(3,3), zeta(3,3)
  real(kind=rk):: Jp(3,3), s_orth(3,3)
  real(kind=rk):: phir(3,3,9), phiz(3,3,9)
  real(kind=rk):: uintfac(3,3), urintfac(3,3), uzintfac(3,3), &
       vintfac(3,3), vrintfac(3,3), vzintfac(3,3), pintfac(3,3)
  real(kind=rk):: rdotintfac(3,3), zdotintfac(3,3), udotintfac(3,3), vdotintfac(3,3)
  real(kind=rk):: udotlocal(9), vdotlocal(9), rdotlocal(9), zdotlocal(9)
  real(kind=rk):: rsi_down(3),  zsi_down(3), rsi_up(3), zsi_up(3), reta_left(3), zeta_left(3), &
       reta_right(3), zeta_right(3)
  real(kind=rk):: rintfac_right(3), uintfac_right(3), vintfac_right(3), &
       rdotintfac_right(3), zdotintfac_right(3)


  !for subroutine define_sf
  integer(kind=ik):: ipp
  real(kind=rk):: Aterm(3,3), Bterm(3,3)
  real(kind=rk):: integrandRsi_V(3,3), integrandReta_V(3,3), &
       integrandRu_V(3,3), integrandRv_V(3,3), integrandRp(3,3)
  real(kind=rk), allocatable:: sf(:,:)
  real(kind=rk):: integrandRsi_S(3), integrandReta_S(3), integrandRu_S(3), integrandRv_S(3)
  real(kind=rk):: M1 = 0.0d0, M2 = 0.0d0
  real(kind=rk), parameter:: eps1 = 1.0d0, eps2 = 1.0d0, epss = 0.1d0
  real(kind=rk):: Oh, Grav, Kdi = 1.0d0     !Kdi: k, used before p as the dimensionless group


  !for subroutine values_in_sj
  real(kind=rk):: s_orth_r(3,3), s_orth_z(3,3)
  real(kind=rk):: Aterm_r(3,3),Aterm_z(3,3), Bterm_r(3,3), Bterm_z(3,3)
  real(kind=rk):: Jp_r(3,3), Jp_z(3,3), rJp_r(3,3)
  real(kind=rk)::  phir_r(3,3,9), phir_z(3,3,9), phiz_r(3,3,9), phiz_z(3,3,9)
  real(kind=rk):: urintfac_r(3,3), urintfac_z(3,3), uzintfac_r(3,3), uzintfac_z(3,3), &
       vrintfac_r(3,3), vrintfac_z(3,3), vzintfac_r(3,3), vzintfac_z(3,3)




  !for subroutine VI_in_sj
  real(kind=rk):: integrandRsi_r_V(3,3), integrandRsi_z_V(3,3), &
       integrandReta_r_V(3,3), integrandReta_z_V(3,3)
  real(kind=rk):: integrandRu_r_V(3,3), integrandRu_z_V(3,3), &
       integrandRu_u(3,3), integrandRuv(3,3), integrandRu_p(3,3)
  real(kind=rk):: integrandRv_r_V(3,3), integrandRv_z_V(3,3), &
       integrandRv_u(3,3), integrandRvv(3,3),integrandRv_p(3,3) 
  real(kind=rk):: integrandRp_r(3,3), integrandRp_z(3,3), &
       integrandRp_u(3,3), integrandRp_v(3,3)
  real(kind=rk), allocatable:: sj(:,:,:,:)


  !for subroutine SVI_in_sj
  integer(kind=ik):: jpp
  real(kind=rk):: integrandRsi_r_S(3), integrandRsi_z_S(3), &
       integrandReta_r_S(3), integrandReta_z_S(3)
  real(kind=rk):: integrandRsi_u_S(3), integrandRsi_v_S(3), &
       integrandRu_r_S(3), integrandRu_z_S(3), integrandRv_r_S(3), integrandRv_z_S(3)


  !for subroutine Dirichlet_BC
  real(kind=rk), allocatable:: Jac(:,:), Res(:)



!for subroutine check
  integer(kind=ik):: p, q
  real(kind=rk):: TOL





contains

  subroutine variableN      !defines MDF & NOPP & LMDF & LNOPP
    implicit none

    NNX = 2*NEX + 1
    NTN = NNX*( 2*NEY + 1 )

    allocate( MDF(NTN), NOPP(NTN) )

    MDF(:) = LNVar-1
    do i = 1, NNX, 2
       do j = 0, NEY ,1
          MDF( i + j*2*NNX ) = LNVar
       end do
    end do

    NOPP(:) = 0
    do i = 1, NTN, 1
       do j = 1, i-1, 1
          NOPP(i) = NOPP(i) + MDF(j)
       end do
       NOPP(i) = NOPP(i) + 1
    end do

    NVar = NOPP(NTN) + MDF(NTN) - 1

    !--------LMDF & LNOPP---------
    LMDF(:) = LNVar-1
    LMDF(1) = LNVar
    LMDF(3) = LNVar
    LMDF(7) = LNVar
    LMDF(9) = LNVar
    LNOPP(:) = 0
    do i = 1, 9, 1
       do j = 1, i-1, 1
          LNOPP(i) = LNOPP(i) + LMDF(j)
       end do
       LNOPP(i) = LNOPP(i) + 1
    end do



  end subroutine variableN





  subroutine initial_condition
    implicit none

    integer(kind=ik):: eleN, locN
    real(kind=rk):: phi, d

    NTE = NEX*NEY
    allocate( globalNM(NTE,9), rowNM(NTE), columnNM(NTE) )
    rcoordinate(:) = 0.0d0
    zcoordinate(:) = 0.0d0

    do locN = 1, 9, 1
       do eleN = 1, NTE, 1
          call NOP(eleN, locN, NEX)
          globalNM(eleN,locN) = globalN
          rowNM(eleN) = rowN
          columnNM(eleN) = columnN
       end do
    end do

    do globalN = 1, NTN, 1

       if( mod( dble(globalN),dble(NNX) ) .eq. 0.0d0 ) then
          rowN = globalN/NNX           !no dble, rowN of nodes not elements (different from rowN in NOP)
          columnN = NNX
       else
          rowN = globalN/NNX + 1         !no dble
          columnN = mod( dble(globalN),dble(NNX) )
       end if

       zcoordinate( globalN ) = H/dble(2*NEY)*dble(rowN-1)
       rcoordinate( globalN ) = ( R - 0.1d0*cos( zcoordinate(globalN)*3.14d0/H ) )/dble(NNX-1)*dble(columnN-1)

    end do

    usol(:) = 0.0d0
    vsol(:) = 0.0d0
    psol(:) = 0.0d0    !include p at the node and p needed to be interpolated

  end subroutine initial_condition




  subroutine basis_function
    implicit none

    integer(kind=ik):: k,l

    !*******************save phii into phi, phiisi into phisi, phiieta into phieta**************************
    !*******************save psii into psi, psiisi into psisi, psiieta into psieta**************************
    do j = 1, 9, 1
       do k = 1, 3, 1
          do l = 1, 3, 1
             phi(k,l,j) = phii( gausspoint(k), gausspoint(l), j )
             phisi(k,l,j) = phiisi( gausspoint(k), gausspoint(l), j )
             phieta(k,l,j) = phiieta( gausspoint(k), gausspoint(l), j )
          end do
       end do
    end do
    ! write(*,*) 'phi:', phi

    psi(:,:,:) = 0.0d0     !except 1, 3, 7, 9, other elements are 0.0d0
    psisi(:,:,:) = 0.0d0
    psieta(:,:,:) = 0.0d0  
    do j = 1, 4, 1            !except psi(:,:,1) psi(:,:,3) psi(:,:,7) psi(:,:,9), psi(:,:,:) = 0.0d0
       do k = 1, 3, 1
          do l = 1, 3, 1
             psi( k,l, convert49(j) ) = psii( gausspoint(k), gausspoint(l), j )
             psisi( k,l,convert49(j) ) = psiisi( gausspoint(l), j )
             psieta( k,l,convert49(j) ) = psiieta( gausspoint(k), j )
          end do
       end do
    end do
    !write(*,*) 'psi:', psi

    do j = 1, 3, 1
       do k = 1, 3, 1
          phi_1d(k,j) = phii_1d( gausspoint(k), j )
          phix_1d(k,j) = phiix_1d( gausspoint(k), j )
       end do
    end do
    !******************************************************************************************************

  end subroutine basis_function










  subroutine graph
    implicit none

    if (timestep.eq.0) then
    !if (step.eq.0) then
       open(unit = 10, file = 'mesh.dat', status = 'replace')
    else
       open(unit = 10, file = 'mesh.dat', status = 'old', access = 'append')
    end if


    write(10, '(A)') 'variables = "r", "z", "u", "v", "p"'
    write(10,'(A,es14.7,A,i8,A,i8,A)') 'Zone T = "mesh", STRANDID = 1, SOLUTIONTIME =', time, &
         ', Datapacking = Point, Zonetype = FEQuadrilateral, N =', NTN, ', E =', NTE, &
         ', DT = (double,double,double,double,double)'



    ! write(10,'(A,i8,A,i8,A,i8,A)') 'Zone T = "mesh", STRANDID = 1, SOLUTIONTIME =', step, &
    !      ', Datapacking = Point, Zonetype = FEQuadrilateral, N =', NTN, ', E =', NTE, &
    !      ', DT = (double,double,double,double,double)'


    do i = 1, NTN, 1
       write(10,'(5es15.7)') rcoordinate(i), zcoordinate(i), usol(i), vsol(i), psol(i)
    end do

    !form the quadrilateral with nodes
    do i = 1, NTE, 1
       write(10,'(4i8)') globalNM(i,1), globalNM(i,3), globalNM(i,9), globalNM(i,7)
    end do

    close(10)

  end subroutine graph

  
  
  
  subroutine prediction
    implicit none



    timestep = timestep + 1
    solp = sol

    !define dt
    dtp = dt
    !for first 5 steps, dt doesn't need to be redefined; after 5 steps, do the following
    if (timestep.gt.5) then
       dt = dtp*( eps/trunerr )**(1.0d0/3.0d0)
    end if
    time = time + dt

    soldotpp = soldotp
    soldotp = soldot

    !define solpred, viz. the initial guess for each time step
    if (timestep.le.5) then
       solpred = solp
    else
       solpred = solp + 0.5d0*dt*( ( 2.0d0 + dt/dtp )*soldotp - dt/dtp*soldotpp )
    end if
    sol = solpred


    !define CTJ: the coefficient of time term in Jac. CTJ will be used when difining Jac
    if (timestep.le.5) then
       CTJ = 1.0d0
    else
       CTJ = 2.0d0
    end if

  end subroutine prediction





  subroutine values_in_an_element
    implicit none


    !give value to r1-r9 & z1-z9
    !define ulocal(9), vlocal(9), plocal(4)
    do j = 1, 9, 1
       


       rlocal(j) = sol( NOPP( globalNM(m,j) ) + Nr )
       zlocal(j) = sol( NOPP( globalNM(m,j) ) + Nz )
       ulocal(j) = sol( NOPP( globalNM(m,j) ) + Nu )
       vlocal(j) = sol( NOPP( globalNM(m,j) ) + Nv )
       if( MDF( globalNM(m,j) ) .gt. Np )  plocal(j) = sol( NOPP( globalNM(m,j) ) + Np )   ! plocal(2, 4, 5, 6, 8) remain unchanged

       ! rlocal(j) = rcoordinate( globalNM(m,j) )
       ! zlocal(j) = zcoordinate( globalNM(m,j) )
       ! ulocal(j) = usol( globalNM(m,j) )
       ! vlocal(j) = vsol( globalNM(m,j) )
       ! !if( MDF( globalNM(m,j) ) .gt. Np ) 
       ! plocal(j) = psol( globalNM(m,j) )   ! plocal(2, 4, 5, 6, 8) = 0.0d0

       rdotlocal(j) = soldot( NOPP( globalNM(m,j) ) + Nr )
       zdotlocal(j) = soldot( NOPP( globalNM(m,j) ) + Nz )
       udotlocal(j) = soldot( NOPP( globalNM(m,j) ) + Nu )
       vdotlocal(j) = soldot( NOPP( globalNM(m,j) ) + Nv )

    end do


    rintfac(:,:) = 0.0d0
    rsi(:,:) = 0.0d0
    reta(:,:) = 0.0d0
    zsi(:,:) = 0.0d0
    zeta(:,:) = 0.0d0
    do k = 1, 3, 1          !relate to a(3) (the value of si for gaussian_quadrature)
       do l = 1, 3, 1           !relate to a(3) (the value of eta for gaussian_quadrature)
          !define rsi, reta, zsi, zeta
          do n = 1, 9, 1
             rintfac(k,l) = rintfac(k,l) + rlocal(n)*phi(k,l,n)
             rsi(k,l) = rsi(k,l) + rlocal(n)*phisi(k,l,n)
             reta(k,l) = reta(k,l) + rlocal(n)*phieta(k,l,n)
             zsi(k,l) = zsi(k,l) + zlocal(n)*phisi(k,l,n)
             zeta(k,l) = zeta(k,l) + zlocal(n)*phieta(k,l,n)
          end do
          !define Jp(3,3)
          Jp(k,l) = rsi(k,l)*zeta(k,l) - reta(k,l)*zsi(k,l)
          s_orth(k,l) = ( ( rsi(k,l)**2 + zsi(k,l)**2 )/( reta(k,l)**2 + zeta(k,l)**2 ) )**0.5d0

          !define phir, phiz
          do n = 1, 9, 1           !n is the notation of phi (phi1 - phi9)
             phir(k,l,n) = 1.0d0/Jp(k,l) * &
                  ( zeta(k,l)*phisi(k,l,n) - zsi(k,l)*phieta(k,l,n) )
             phiz(k,l,n) = 1.0d0/Jp(k,l) * &
                  ( -reta(k,l)*phisi(k,l,n) + rsi(k,l)*phieta(k,l,n) )
          end do

       end do
    end do



    !define uintfac, urintfac, uzintfac, vintfac, vrintfac, vzintfac
    uintfac(:,:) = 0.0d0
    urintfac(:,:) = 0.0d0
    uzintfac(:,:) = 0.0d0
    vintfac(:,:) = 0.0d0
    vrintfac(:,:) = 0.0d0
    vzintfac(:,:) = 0.0d0
    pintfac(:,:) = 0.0d0

    rdotintfac(:,:) = 0.0d0
    zdotintfac(:,:) = 0.0d0
    udotintfac(:,:) = 0.0d0
    vdotintfac(:,:) = 0.0d0

    do k = 1, 3
       do l = 1, 3

          do n = 1, 9, 1
             uintfac(k,l) = uintfac(k,l) +  ulocal(n)*phi(k,l,n)
             urintfac(k,l) = urintfac(k,l) +  ulocal(n)*phir(k,l,n)
             uzintfac(k,l) = uzintfac(k,l) +  ulocal(n)*phiz(k,l,n)
             vintfac(k,l) = vintfac(k,l) +  vlocal(n)*phi(k,l,n)
             vrintfac(k,l) = vrintfac(k,l) +  vlocal(n)*phir(k,l,n)
             vzintfac(k,l) = vzintfac(k,l) +  vlocal(n)*phiz(k,l,n)
             pintfac(k,l) =  pintfac(k,l) +  plocal(n)*psi(k,l,n)

             rdotintfac(k,l) = rdotintfac(k,l) + rdotlocal(n)*phi(k,l,n)
             zdotintfac(k,l) = zdotintfac(k,l) + zdotlocal(n)*phi(k,l,n)
             udotintfac(k,l) = udotintfac(k,l) + udotlocal(n)*phi(k,l,n)
             vdotintfac(k,l) = vdotintfac(k,l) + vdotlocal(n)*phi(k,l,n)
          end do

       end do
    end do   !end loop for k&l, preparation for gaussian_quadrature




!!!!!!!!!!!!!!!!!!!!!!!!!!preparation for the SIs, define the temrs in SI!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !other than free surface, SIs only exit in elliptic mesh equations
    rsi_down(:) = 0.0d0
    zsi_down(:) = 0.0d0
    rsi_up(:) = 0.0d0
    zsi_up(:) = 0.0d0
    reta_left(:) = 0.0d0
    zeta_left(:) = 0.0d0
    reta_right(:) = 0.0d0
    zeta_right(:) = 0.0d0

    rintfac_right(:) = 0.0d0
    uintfac_right(:) = 0.0d0
    vintfac_right(:) = 0.0d0
    rdotintfac_right(:) = 0.0d0
    zdotintfac_right(:) = 0.0d0

    do k = 1, 3, 1  !the three gausspoints for SI

       do n = 1, 3, 1  !the summation of three terms, eg: rsi = sum( rlocal(7,8,9)*phix_1d(1,2,3) )

          if ( rowNM(m).eq.1 ) then     
             !reta, zeta not appear in the SI of Rsi, and the SI of Reta is 0 because d(eta)=0
             !so reta, zeta are not needed
             npp = n  !only need r1, r2, r3 -->r(npp)
             rsi_down(k) = rsi_down(k) + rlocal(npp)*phix_1d(k,n)
             zsi_down(k) = zsi_down(k) + zlocal(npp)*phix_1d(k,n)
          end if

          if ( rowNM(m).eq.NEY ) then
             npp = n + 6  !only need r7, r8, r9 -->r(npp)
             rsi_up(k) = rsi_up(k) + rlocal(npp) * phix_1d(k,n)
             zsi_up(k) = zsi_up(k) + zlocal(npp) * phix_1d(k,n)
          end if

          if ( columnNM(m).eq.1 ) then
             npp = 3*n - 2  !only need r1, r4, r7 -->r(npp)
             reta_left(k) = reta_left(k) + rlocal(npp) * phix_1d(k,n)
             zeta_left(k) = zeta_left(k) + zlocal(npp) * phix_1d(k,n)
          end if

          if ( columnNM(m).eq.NEX ) then
             npp = 3*n  !only need r3, r6, r9 -->r(npp)
             reta_right(k) = reta_right(k) + rlocal(npp) * phix_1d(k,n)
             zeta_right(k) = zeta_right(k) + zlocal(npp) * phix_1d(k,n)

             rintfac_right(k) = rintfac_right(k) + rlocal(npp) * phi_1d(k,n)
             uintfac_right(k) = uintfac_right(k) + ulocal(npp) * phi_1d(k,n)
             vintfac_right(k) = vintfac_right(k) + vlocal(npp) * phi_1d(k,n)
             rdotintfac_right(k) = rdotintfac_right(k) + rdotlocal(npp) * phi_1d(k,n)
             zdotintfac_right(k) = zdotintfac_right(k) + zdotlocal(npp) * phi_1d(k,n)

          end if

       end do  !end for n
    end do    !end for k

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  end subroutine values_in_an_element





  subroutine define_sf
    implicit none


    do k = 1, 3, 1
       do l = 1, 3, 1

          !Aterm(k,l,i)
          Aterm(k,l) = ( zeta(k,l)**2 + reta(k,l)**2 )*phisi(k,l,i) - &
               ( zeta(k,l)*zsi(k,l) + reta(k,l)*rsi(k,l) )*phieta(k,l,i)
          Bterm(k,l) = -( zsi(k,l)*zeta(k,l) + rsi(k,l)*reta(k,l) )*phisi(k,l,i) &
               + ( zsi(k,l)**2 + rsi(k,l)**2 )*phieta(k,l,i)

          integrandRsi_V(k,l) = ( s_orth(k,l) + epss )*Aterm(k,l)/Jp(k,l) - &
               eps1*phisi(k,l,i)*f_size( gausspoint(k) )*log( rsi(k,l)**2 + zsi(k,l)**2 )

          integrandReta_V(k,l) = ( 1.0d0/s_orth(k,l) + epss )*Bterm(k,l)/Jp(k,l) - &
               eps2*phieta(k,l,i)*g_size( gausspoint(l) )*log( reta(k,l)**2 + zeta(k,l)**2 )


          integrandRu_V(k,l) = ( phi(k,l,i)*( udotintfac(k,l) + ( uintfac(k,l) - rdotintfac(k,l) )*urintfac(k,l) +  &
               ( vintfac(k,l) - zdotintfac(k,l) )*uzintfac(k,l) )  - &
               Kdi*pintfac(k,l)*Oh*( phir(k,l,i) + phi(k,l,i)/rintfac(k,l) ) + &
               Oh*( 2.0d0*urintfac(k,l)*phir(k,l,i) + ( uzintfac(k,l) + vrintfac(k,l) )*phiz(k,l,i) + &
               phi(k,l,i)*2.0d0/rintfac(k,l)**2 *uintfac(k,l) ) )  *rintfac(k,l)*abs(Jp(k,l))

          integrandRv_V(k,l) = ( phi(k,l,i)*( vdotintfac(k,l) + ( uintfac(k,l) - rdotintfac(k,l) )*vrintfac(k,l) + &
               ( vintfac(k,l) - zdotintfac(k,l) )*vzintfac(k,l) + Grav ) - Kdi*pintfac(k,l)*Oh*phiz(k,l,i) + &
               Oh*( ( uzintfac(k,l) + vrintfac(k,l) ) *phir(k,l,i) + 2.0d0*vzintfac(k,l)*phiz(k,l,i) ) ) &
               *rintfac(k,l)*abs(Jp(k,l))

          integrandRp(k,l) = psi(k,l,i)* ( urintfac(k,l) + uintfac(k,l)/rintfac(k,l) + vzintfac(k,l) ) &
               *rintfac(k,l)*abs(Jp(k,l))
       end do
    end do


    sf(i,NNr) = gaussian_quadrature(integrandRsi_V)
    sf(i,NNz) = gaussian_quadrature(integrandReta_V)
    sf(i,NNu) = gaussian_quadrature(integrandRu_V)
    sf(i,NNv) = gaussian_quadrature(integrandRv_V)
    sf(i,NNp) = gaussian_quadrature(integrandRp)    !sf( (2,4,5,6,8) ,5) = 0.0d0



    !*******************************************adding SI to sf********************************************************

    if( (rowNM(m).eq.1) .and. ( (i.eq.1) .or. (i.eq.2) .or. (i.eq.3) ) )  then
       do k = 1, 3, 1    !three gausspoints
          ipp = i  !phix_1d(k,ipp)
          integrandRsi_S(k) = phix_1d(k,ipp) * f_size( gausspoint(k) ) * log( rsi_down(k)**2 + zsi_down(k)**2 )
       end do
       sf(i,NNr) = sf(i,NNr)  -  M1*gaussian_quadrature_1d(integrandRsi_S)
    end if

    if( (rowNM(m).eq.NEY) .and. ( (i.eq.7) .or. (i.eq.8) .or. (i.eq.9) ) )  then
       do k = 1, 3, 1    !three gausspoints
          ipp = i - 6  !phix_1d(k,ipp)
          integrandRsi_S(k) = phix_1d(k,ipp) * f_size( gausspoint(k) ) * log( rsi_up(k)**2 + zsi_up(k)**2 )
       end do
       sf(i,NNr) = sf(i,NNr)  -  M1*gaussian_quadrature_1d(integrandRsi_S)
    end if

    if( (columnNM(m).eq.1) .and. ( (i.eq.1) .or. (i.eq.4) .or. (i.eq.7) ) )  then
       do k = 1, 3, 1    !three gausspoints
          ipp = i/3 + 1  !phix_1d(k,ipp)
          integrandReta_S(k) = phix_1d(k,ipp) * g_size( gausspoint(k) ) * log( reta_left(k)**2 + zeta_left(k)**2 )
       end do
       sf(i,NNz) = sf(i,NNz)  -  M2*gaussian_quadrature_1d(integrandReta_S)
    end if

    if( (columnNM(m).eq.NEX) .and. ( (i.eq.3) .or. (i.eq.6) .or. (i.eq.9) ) )  then
       do k = 1, 3, 1    !three gausspoints
          ipp = i/3  !phix_1d(k,ipp)
          integrandReta_S(k) = phix_1d(k,ipp) * g_size( gausspoint(k) ) * log( reta_right(k)**2 + zeta_right(k)**2 )


          integrandRsi_S(k) = phi_1d(k,ipp)*( -zeta_right(k)*( uintfac_right(k) - rdotintfac_right(k) ) + &
               reta_right(k)*( vintfac_right(k) - zdotintfac_right(k) ) )*rintfac_right(k)

          integrandRu_S(k) = ( reta_right(k)*phix_1d(k,ipp) / ( reta_right(k)**2 + zeta_right(k)**2 ) + &
               phi_1d(k,ipp)/rintfac_right(k) )*rintfac_right(k)*( reta_right(k)**2 + zeta_right(k)**2 )**0.5d0

          integrandRv_S(k) = zeta_right(k)*phix_1d(k,ipp) / ( reta_right(k)**2 + zeta_right(k)**2 )**0.5d0 &
               *rintfac_right(k)

       end do
       sf(i,NNz) = sf(i,NNz)  -  M2*gaussian_quadrature_1d(integrandReta_S)

       sf(i,NNr) = gaussian_quadrature_1d(integrandRsi_S)          !directly replace Rsi_V with Rsi_S, viz KBC
       sf(i,NNu) = sf(i,NNu)  + gaussian_quadrature_1d(integrandRu_S)
       sf(i,NNv) = sf(i,NNv)  + gaussian_quadrature_1d(integrandRv_S)
    end if

    !*****************************************************************************************************************



  end subroutine define_sf




subroutine values_in_sj
implicit none


 do k = 1, 3, 1          !relate to a(3) (the value of si for gaussian_quadrature)
          do l = 1, 3, 1           !relate to a(3) (the value of eta for gaussian_quadrature)

             !Actually, these terms are (k,l,i,j), but can be refurbished in each cycle of i&j, so just need (k,l)
             !s_orth_r(k,l,i,j)
             s_orth_r(k,l) = 1.0d0 / ( reta(k,l)**2 + zeta(k,l)**2 ) * ( rsi(k,l)*phisi(k,l,j)/s_orth(k,l) &
                  - reta(k,l)*phieta(k,l,j)*s_orth(k,l) )

             !s_orth_z(k,l,i,j)
             s_orth_z(k,l) = 1.0d0 / ( reta(k,l)**2 + zeta(k,l)**2 ) * ( zsi(k,l)*phisi(k,l,j)/s_orth(k,l) &
                  - zeta(k,l)*phieta(k,l,j)*s_orth(k,l) )

             !Aterm_r(k,l,i,j)
             Aterm_r(k,l) = 2.0d0*reta(k,l)*phieta(k,l,j)*phisi(k,l,i) &
                  - ( rsi(k,l)*phieta(k,l,j) + reta(k,l)*phisi(k,l,j) )*phieta(k,l,i)

             !Aterm_z(k,l,i,j)
             Aterm_z(k,l) = 2.0d0*zeta(k,l)*phieta(k,l,j)*phisi(k,l,i) &
                  - ( zsi(k,l)*phieta(k,l,j) + zeta(k,l)*phisi(k,l,j) )*phieta(k,l,i)

             !Bterm_r(k,l,i,j)
             Bterm_r(k,l) = - ( reta(k,l)*phisi(k,l,j) + rsi(k,l)*phieta(k,l,j) )*phisi(k,l,i) &
                  + 2.0d0*rsi(k,l)*phisi(k,l,j)*phieta(k,l,i) 

             !Bterm_z(k,l,i,j)
             Bterm_z(k,l) = - ( zeta(k,l)*phisi(k,l,j) + zsi(k,l)*phieta(k,l,j) )*phisi(k,l,i) &
                  + 2.0d0*zsi(k,l)*phisi(k,l,j)*phieta(k,l,i) 

             !Jp_r((k,l,i,j)
             Jp_r(k,l) = phisi(k,l,j)*zeta(k,l) - phieta(k,l,j)*zsi(k,l)

             !Jp_r((k,l,i,j)
             Jp_z(k,l) = rsi(k,l)*phieta(k,l,j) - reta(k,l)*phisi(k,l,j)

             !rJp_r(k,l,i,j)
             rJp_r(k,l) = phi(k,l,j)*Jp(k,l) + rintfac(k,l)*Jp_r(k,l)


             do n = 1, 9            !phir_r(k,l,n,j)
                phir_r(k,l,n) = -1.0d0/Jp(k,l)**2 *Jp_r(k,l)*( phisi(k,l,n)*zeta(k,l) - phieta(k,l,n)*zsi(k,l) )     !d phir(n) / d rj

                phir_z(k,l,n) = -1.0d0/Jp(k,l)**2 *Jp_z(k,l)*( phisi(k,l,n)*zeta(k,l) - phieta(k,l,n)*zsi(k,l) ) + &
                     1/Jp(k,l)*( phisi(k,l,n)*phieta(k,l,j) - phieta(k,l,n)*phisi(k,l,j) )

                phiz_r(k,l,n) = -1.0d0/Jp(k,l)**2 *Jp_r(k,l)*( -phisi(k,l,n)*reta(k,l) + phieta(k,l,n)*rsi(k,l) ) + &
                     1/Jp(k,l)*( -phisi(k,l,n)*phieta(k,l,j) + phieta(k,l,n)*phisi(k,l,j) )

                phiz_z(k,l,n) = -1.0d0/Jp(k,l)**2 *Jp_z(k,l)*( -phisi(k,l,n)*reta(k,l) + phieta(k,l,n)*rsi(k,l) )
             end do


             !urintfac_r(k,l,j)
             urintfac_r(k,l) = 0.0d0
             urintfac_z(k,l) = 0.0d0
             uzintfac_r(k,l) = 0.0d0
             uzintfac_z(k,l) = 0.0d0
             vrintfac_r(k,l) = 0.0d0
             vrintfac_z(k,l) = 0.0d0
             vzintfac_r(k,l) = 0.0d0
             vzintfac_z(k,l) = 0.0d0
             do n = 1, 9
                urintfac_r(k,l) = urintfac_r(k,l) + ulocal(n)*phir_r(k,l,n)
                urintfac_z(k,l) = urintfac_z(k,l) + ulocal(n)*phir_z(k,l,n)
                uzintfac_r(k,l) = uzintfac_r(k,l) + ulocal(n)*phiz_r(k,l,n)
                uzintfac_z(k,l) = uzintfac_z(k,l) + ulocal(n)*phiz_z(k,l,n)
                vrintfac_r(k,l) = vrintfac_r(k,l) + vlocal(n)*phir_r(k,l,n)
                vrintfac_z(k,l) = vrintfac_z(k,l) + vlocal(n)*phir_z(k,l,n)
                vzintfac_r(k,l) = vzintfac_r(k,l) + vlocal(n)*phiz_r(k,l,n)
                vzintfac_z(k,l) = vzintfac_z(k,l) + vlocal(n)*phiz_z(k,l,n)
             end do
                
             

          end do
       end do            !end loop for k&l


     end subroutine values_in_sj




subroutine VI_in_sj
implicit none



!define integrand(k,l,p,q):
do k = 1, 3, 1          !relate to a(3) (the value of si for gaussian_quadrature)
   do l = 1, 3, 1           !relate to a(3) (the value of eta for gaussian_quadrature)



      !integrandRsi_u,v,p = integrandReta_u,v,p = 0.0d0

      integrandRsi_r_V(k,l) = s_orth_r(k,l) * Aterm(k,l) / Jp(k,l)  +  &
           ( s_orth(k,l) + epss ) * Aterm_r(k,l) / Jp(k,l)  &
           -  ( s_orth(k,l) + epss ) * Aterm(k,l) / Jp(k,l)**2 * Jp_r(k,l)  &
           -  eps1 * phisi(k,l,i) * f_size( gausspoint(k) ) / ( rsi(k,l)**2 + zsi(k,l)**2 ) &
           * 2.0d0*rsi(k,l) * phisi(k,l,j)

      integrandRsi_z_V(k,l) = s_orth_z(k,l) * Aterm(k,l) / Jp(k,l)  +  &
           ( s_orth(k,l) + epss ) * Aterm_z(k,l) / Jp(k,l)  &
           -  ( s_orth(k,l) + epss ) * Aterm(k,l) / (Jp(k,l)**2) * Jp_z(k,l)  &
           -  eps1 * phisi(k,l,i) * f_size( gausspoint(k) ) / ( rsi(k,l)**2 + zsi(k,l)**2 ) &
           * 2.0d0*zsi(k,l) * phisi(k,l,j) 

      integrandReta_r_V(k,l) = -1.0d0/(s_orth(k,l)**2) * s_orth_r(k,l) * Bterm(k,l) / Jp(k,l)  &
           +  ( 1.0d0/s_orth(k,l) + epss ) * Bterm_r(k,l) / Jp(k,l)  &
           -  ( 1.0d0/s_orth(k,l) + epss ) * Bterm(k,l) / (Jp(k,l)**2) * Jp_r(k,l)  &
           -  eps2 * phieta(k,l,i) * g_size( gausspoint(l) ) / ( reta(k,l)**2 + zeta(k,l)**2 ) &
           * 2.0d0*reta(k,l) * phieta(k,l,j)

      integrandReta_z_V(k,l) =  -1.0d0/s_orth(k,l)**2 * s_orth_z(k,l) * Bterm(k,l) / Jp(k,l)  &
           +  ( 1.0d0/s_orth(k,l) + epss ) * Bterm_z(k,l) / Jp(k,l)  &
           -  ( 1.0d0/s_orth(k,l) + epss ) * Bterm(k,l) / (Jp(k,l)**2) * Jp_z(k,l)  &
           -  eps2 * phieta(k,l,i) * g_size( gausspoint(l) ) / ( reta(k,l)**2 + zeta(k,l)**2 ) &
           * 2.0d0*zeta(k,l) * phieta(k,l,j)


      ! inertial = 
      ! viscous = 
      ! integrandRu_r(k,l) = inertial + viscous
      integrandRu_r_V(k,l) = ( phi(k,l,i)* ( -CTJ*phi(k,l,j)/dt*urintfac(k,l) + &
           ( uintfac(k,l) - rdotintfac(k,l) )*urintfac_r(k,l) + ( vintfac(k,l)- zdotintfac(k,l) )*uzintfac_r(k,l) ) - &
           Kdi*pintfac(k,l)*Oh*( phir_r(k,l,i) - phi(k,l,i)/rintfac(k,l)**2 *phi(k,l,j) ) + &
           Oh*( 2.0d0*urintfac_r(k,l)*phir(k,l,i) + 2.0d0*urintfac(k,l)*phir_r(k,l,i) + &
           ( uzintfac_r(k,l) + vrintfac_r(k,l) )*phiz(k,l,i) + ( uzintfac(k,l) + vrintfac(k,l) )*phiz_r(k,l,i) - &
           4.0d0*phi(k,l,i)*phi(k,l,j)/rintfac(k,l)**3 *uintfac(k,l) ) ) *rintfac(k,l)*abs(Jp(k,l)) + &
           
           ( phi(k,l,i)*( udotintfac(k,l) + ( uintfac(k,l) - rdotintfac(k,l) )*urintfac(k,l) +  &
           ( vintfac(k,l) - zdotintfac(k,l) )*uzintfac(k,l) )  - &
           Kdi*pintfac(k,l)*Oh*( phir(k,l,i) + phi(k,l,i)/rintfac(k,l) ) + &
           Oh*( 2.0d0*urintfac(k,l)*phir(k,l,i) + ( uzintfac(k,l) + vrintfac(k,l) )*phiz(k,l,i) + &
           phi(k,l,i)*2.0d0/rintfac(k,l)**2 *uintfac(k,l) ) ) *rJp_r(k,l) 


      integrandRu_z_V(k,l) = ( phi(k,l,i)* ( ( uintfac(k,l) - rdotintfac(k,l) )*urintfac_z(k,l) - &
           CTJ*phi(k,l,j)/dt*uzintfac(k,l) + ( vintfac(k,l)- zdotintfac(k,l) )*uzintfac_z(k,l) ) - &
           Kdi*pintfac(k,l)*Oh*phir_z(k,l,i) + &
           Oh*( 2.0d0*urintfac_z(k,l)*phir(k,l,i) + 2.0d0*urintfac(k,l)*phir_z(k,l,i) + &
           ( uzintfac_z(k,l) + vrintfac_z(k,l) )*phiz(k,l,i) + ( uzintfac(k,l) + vrintfac(k,l) )*phiz_z(k,l,i) ) ) &
           *rintfac(k,l)*abs(Jp(k,l)) + &
           
           ( phi(k,l,i)*( udotintfac(k,l) + ( uintfac(k,l) - rdotintfac(k,l) )*urintfac(k,l) +  &
           ( vintfac(k,l) - zdotintfac(k,l) )*uzintfac(k,l) )  - &
           Kdi*pintfac(k,l)*Oh*( phir(k,l,i) + phi(k,l,i)/rintfac(k,l) ) + &
           Oh*( 2.0d0*urintfac(k,l)*phir(k,l,i) + ( uzintfac(k,l) + vrintfac(k,l) )*phiz(k,l,i) + &
           phi(k,l,i)*2.0d0/rintfac(k,l)**2 *uintfac(k,l) ) )  *rintfac(k,l)* Jp_z(k,l)



      integrandRu_u(k,l) = ( phi(k,l,i)* ( CTJ*phi(k,l,j)/dt + phi(k,l,j)*urintfac(k,l) +  &
           ( uintfac(k,l) - rdotintfac(k,l) )*phir(k,l,j) + ( vintfac(k,l)- zdotintfac(k,l) )*phiz(k,l,j) ) + &
           Oh*( 2.0d0*phir(k,l,i)*phir(k,l,j) + phiz(k,l,i)*phiz(k,l,j) + 2.0d0/rintfac(k,l)**2 *phi(k,l,i)*phi(k,l,j) ) ) &
           *rintfac(k,l)*abs(Jp(k,l))  

      integrandRuv(k,l) = ( phi(k,l,i)*phi(k,l,j)*uzintfac(k,l) + Oh*phir(k,l,j)*phiz(k,l,i) ) *rintfac(k,l)*abs(Jp(k,l)) 

      integrandRu_p(k,l) = -Kdi*psi(k,l,j)*Oh*( phir(k,l,i) + phi(k,l,i)/rintfac(k,l) ) *rintfac(k,l)*abs(Jp(k,l))
      !j=2,4,5,6,8,  integrandRu_p(k,l) = 0.0d0




      integrandRv_r_V(k,l) = ( phi(k,l,i)* ( -CTJ*phi(k,l,j)/dt*vrintfac(k,l) + &
           ( uintfac(k,l) - rdotintfac(k,l) )*vrintfac_r(k,l) + ( vintfac(k,l)- zdotintfac(k,l) )*vzintfac_r(k,l) ) - &
           Kdi*pintfac(k,l)*Oh*phiz_r(k,l,i) + &
           Oh*( ( uzintfac_r(k,l) + vrintfac_r(k,l) )*phir(k,l,i) + ( uzintfac(k,l) + vrintfac(k,l) )*phir_r(k,l,i) + &
           2.0d0*vzintfac_r(k,l)*phiz(k,l,i) + 2.0d0*vzintfac(k,l)*phiz_r(k,l,i) ) ) *rintfac(k,l)*abs(Jp(k,l)) + &
           
           ( phi(k,l,i)*( vdotintfac(k,l) + ( uintfac(k,l) - rdotintfac(k,l) )*vrintfac(k,l) + &
           ( vintfac(k,l) - zdotintfac(k,l) )*vzintfac(k,l) + Grav ) - Kdi*pintfac(k,l)*Oh*phiz(k,l,i) + &
           Oh*( ( uzintfac(k,l) + vrintfac(k,l) ) *phir(k,l,i) + 2.0d0*vzintfac(k,l)*phiz(k,l,i) ) ) *rJp_r(k,l) 


      integrandRv_z_V(k,l) = ( phi(k,l,i)* ( ( uintfac(k,l) - rdotintfac(k,l) )*vrintfac_z(k,l) - &
           CTJ*phi(k,l,j)/dt*vzintfac(k,l) + ( vintfac(k,l)- zdotintfac(k,l) )*vzintfac_z(k,l) ) - &
           Kdi*pintfac(k,l)*Oh*phiz_z(k,l,i) + &
           Oh*( ( uzintfac_z(k,l) + vrintfac_z(k,l) )*phir(k,l,i) + ( uzintfac(k,l) + vrintfac(k,l) )*phir_z(k,l,i) + &
           2.0d0*vzintfac_z(k,l)*phiz(k,l,i) + 2.0d0*vzintfac(k,l)*phiz_z(k,l,i) ) ) *rintfac(k,l)*abs(Jp(k,l)) + &
           
           ( phi(k,l,i)*( vdotintfac(k,l) + ( uintfac(k,l) - rdotintfac(k,l) )*vrintfac(k,l) + &
           ( vintfac(k,l) - zdotintfac(k,l) )*vzintfac(k,l) + Grav ) - Kdi*pintfac(k,l)*Oh*phiz(k,l,i) + &
           Oh*( ( uzintfac(k,l) + vrintfac(k,l) ) *phir(k,l,i) + 2.0d0*vzintfac(k,l)*phiz(k,l,i) ) ) *rintfac(k,l)* Jp_z(k,l)


      integrandRv_u(k,l) = ( phi(k,l,i)*phi(k,l,j)*vrintfac(k,l) + Oh*phiz(k,l,j)*phir(k,l,i) ) *rintfac(k,l)*abs(Jp(k,l)) 

      integrandRvv(k,l) = ( phi(k,l,i)*( CTJ*phi(k,l,j)/dt + ( uintfac(k,l) - rdotintfac(k,l) )*phir(k,l,j) + &
           phi(k,l,j)*vzintfac(k,l) + (vintfac(k,l) - zdotintfac(k,l) )*phiz(k,l,j) ) + &
           Oh*( phir(k,l,i)*phir(k,l,j) + 2.0d0*phiz(k,l,i)*phiz(k,l,j) ) ) *rintfac(k,l)*abs(Jp(k,l)) 


      integrandRv_p(k,l) = -Kdi*psi(k,l,j)*Oh*phiz(k,l,i) *rintfac(k,l)*abs(Jp(k,l))  




      integrandRp_r(k,l) = psi(k,l,i)* ( urintfac_r(k,l) - uintfac(k,l)/rintfac(k,l)**2 *phi(k,l,j) + vzintfac_r(k,l) ) &
           *rintfac(k,l)*abs(Jp(k,l)) + &
           
           psi(k,l,i)* ( urintfac(k,l) + uintfac(k,l)/rintfac(k,l) + vzintfac(k,l) ) *rJp_r(k,l)


      integrandRp_z(k,l) = psi(k,l,i)* ( urintfac_z(k,l) + vzintfac_z(k,l) ) *rintfac(k,l)*abs(Jp(k,l)) + &
           
           psi(k,l,i)* ( urintfac(k,l) + uintfac(k,l)/rintfac(k,l) + vzintfac(k,l) ) *rintfac(k,l)* Jp_z(k,l)


      integrandRp_u(k,l) = ( phi(k,l,j)/rintfac(k,l) + phir(k,l,j) )*psi(k,l,i) *rintfac(k,l)*abs(Jp(k,l))

      integrandRp_v(k,l) = phiz(k,l,j)*psi(k,l,i) *rintfac(k,l)*abs(Jp(k,l)) 




   end do
end do   !end loop for k&l, preparation for gaussian_quadrature



sj(i,j,NNr,NNr) = gaussian_quadrature(integrandRsi_r_V)          ! sjRsi_r(i,j)   
sj(i,j,NNr,NNz) = gaussian_quadrature(integrandRsi_z_V)          ! sjRsi_z(i,j)  
sj(i,j,NNr,NNu) = 0.0d0                                          ! sjRsi_u(i,j)   
sj(i,j,NNr,NNv) = 0.0d0                                          ! sjRsi_v(i,j)  
sj(i,j,NNr,NNp) = 0.0d0                                          ! sjRsi_p(i,j)  

sj(i,j,NNz,NNr) = gaussian_quadrature(integrandReta_r_V)           ! sjReta_r(i,j)   
sj(i,j,NNz,NNz) = gaussian_quadrature(integrandReta_z_V)           ! sjReta_z(i,j)  
sj(i,j,NNz,NNu) = 0.0d0                                          ! sjReta_u(i,j)   
sj(i,j,NNz,NNv) = 0.0d0                                          ! sjReta_v(i,j)  
sj(i,j,NNz,NNp) = 0.0d0                                          ! sjReta_p(i,j)  

sj(i,j,NNu,NNr) = gaussian_quadrature(integrandRu_r_V)           ! sjRur(i,j)   
sj(i,j,NNu,NNz) = gaussian_quadrature(integrandRu_z_V)           ! sjRuz(i,j) 
sj(i,j,NNu,NNu) = gaussian_quadrature(integrandRu_u)           ! sjRuu(i,j)   
sj(i,j,NNu,NNv) = gaussian_quadrature(integrandRuv)           ! sjRuv(i,j)  
sj(i,j,NNu,NNp) = gaussian_quadrature(integrandRu_p)           ! sjRup(i,j) 

sj(i,j,NNv,NNr) = gaussian_quadrature(integrandRv_r_V)           ! sjRvr(i,j)   
sj(i,j,NNv,NNz) = gaussian_quadrature(integrandRv_z_V)           ! sjRvz(i,j) 
sj(i,j,NNv,NNu) = gaussian_quadrature(integrandRv_u)           ! sjRvu(i,j)   
sj(i,j,NNv,NNv) = gaussian_quadrature(integrandRvv)           ! sjRvv(i,j)  
sj(i,j,NNv,NNp) = gaussian_quadrature(integrandRv_p)           ! sjRvp(i,j) 

sj(i,j,NNp,NNr) = gaussian_quadrature(integrandRp_r)           ! sjRpr(i,j)   
sj(i,j,NNp,NNz) = gaussian_quadrature(integrandRp_z)           ! sjRpz(i,j) 
sj(i,j,NNp,NNu) = gaussian_quadrature(integrandRp_u)           ! sjRpu(i,j)   
sj(i,j,NNp,NNv) = gaussian_quadrature(integrandRp_v)           ! sjRpv(i,j)  
sj(i,j,NNp,NNp) = 0.0d0                                        ! sjRpp(i,j) 



end subroutine VI_in_sj




subroutine SI_in_sj
implicit none



   !*********************************************adding SI to sj*******************************************************

   if( (rowNM(m).eq.1) .and. ( (i.eq.1) .or. (i.eq.2) .or. (i.eq.3) ) .and. ( (j.eq.1) .or. (j.eq.2) .or. (j.eq.3) ) ) then
      do k = 1, 3, 1    !three gausspoints
         ipp = i  !phix_1d(k,ipp)
         jpp = j  !phix_1d(k,jpp)
         integrandRsi_r_S(k) = phix_1d(k,ipp) * f_size( gausspoint(k) ) / ( rsi_down(k)**2 + zsi_down(k)**2 ) &
              * 2.0d0*rsi_down(k) * phix_1d(k,jpp)
         integrandRsi_z_S(k) = phix_1d(k,ipp) * f_size( gausspoint(k) ) / ( rsi_down(k)**2 + zsi_down(k)**2 ) &
              * 2.0d0*zsi_down(k) * phix_1d(k,jpp)
      end do
      sj(i,j,NNr,NNr) = sj(i,j,NNr,NNr) - M1*gaussian_quadrature_1d(integrandRsi_r_S)
      sj(i,j,NNr,NNz) = sj(i,j,NNr,NNz) - M1*gaussian_quadrature_1d(integrandRsi_z_S)
   end if

   if( (rowNM(m).eq.NEY) .and. ( (i.eq.7) .or. (i.eq.8) .or. (i.eq.9) ) .and. ( (j.eq.7) .or. (j.eq.8) .or. (j.eq.9) ) ) then
      do k = 1, 3, 1    !three gausspoints
         ipp = i - 6  !phix_1d(k,l)
         jpp = j - 6  !phix_1d(k,jpp)
         integrandRsi_r_S(k) = phix_1d(k,ipp) * f_size( gausspoint(k) ) / ( rsi_up(k)**2 + zsi_up(k)**2 ) &
              * 2.0d0*rsi_up(k) * phix_1d(k,jpp)
         integrandRsi_z_S(k) = phix_1d(k,ipp) * f_size( gausspoint(k) ) / ( rsi_up(k)**2 + zsi_up(k)**2 ) &
              * 2.0d0*zsi_up(k) * phix_1d(k,jpp)
      end do
      sj(i,j,NNr,NNr) = sj(i,j,NNr,NNr) - M1*gaussian_quadrature_1d(integrandRsi_r_S)
      sj(i,j,NNr,NNz) = sj(i,j,NNr,NNz) - M1*gaussian_quadrature_1d(integrandRsi_z_S)
   end if

   if( (columnNM(m).eq.1) .and. ( (i.eq.1) .or. (i.eq.4) .or. (i.eq.7) ) .and. ( (j.eq.1) .or. (j.eq.4) .or. (j.eq.7) ) ) then
      do k = 1, 3, 1    !three gausspoints
         ipp = i/3 + 1  !phix_1d(k,ipp)
         jpp = j/3 + 1  !phix_1d(k,jpp)
         integrandReta_r_S(k) = phix_1d(k,ipp) * g_size( gausspoint(k) ) / ( reta_left(k)**2 + zeta_left(k)**2 ) &
              * 2.0d0*reta_left(k) * phix_1d(k,jpp)
         integrandReta_z_S(k) = phix_1d(k,ipp) * f_size( gausspoint(k) ) / ( reta_left(k)**2 + zeta_left(k)**2 ) &
              * 2.0d0*zeta_left(k) * phix_1d(k,jpp)
      end do
      sj(i,j,NNz,NNr) = sj(i,j,NNz,NNr) - M1*gaussian_quadrature_1d(integrandReta_r_S)
      sj(i,j,NNz,NNz) = sj(i,j,NNz,NNz) - M1*gaussian_quadrature_1d(integrandReta_z_S)
   end if


   
   if( (columnNM(m).eq.NEX) .and. ( (i.eq.3) .or. (i.eq.6) .or. (i.eq.9) ) )  then      

   if( (j.eq.3) .or. (j.eq.6) .or. (j.eq.9) ) then
      do k = 1, 3, 1    !three gausspoints
         ipp = i/3  !phix_1d(k,l)
         jpp = j/3  !phix_1d(k,l)
         integrandReta_r_S(k) = phix_1d(k,ipp) * g_size( gausspoint(k) ) / ( reta_right(k)**2 + zeta_right(k)**2 ) &
              * 2.0d0*reta_right(k) * phix_1d(k,jpp)
         integrandReta_z_S(k) = phix_1d(k,ipp) * f_size( gausspoint(k) ) / ( reta_right(k)**2 + zeta_right(k)**2 ) &
              * 2.0d0*zeta_right(k) * phix_1d(k,jpp)


         integrandRsi_r_S(k) = phi_1d(k,ipp)*( zeta_right(k)*CTJ/dt*phi_1d(k,jpp) + &
              phix_1d(k,jpp)*( vintfac_right(k) - zdotintfac_right(k) ) )*rintfac_right(k) + &
              
              phi_1d(k,ipp)*( -zeta_right(k)*( uintfac_right(k) - rdotintfac_right(k) ) + &
              reta_right(k)*( vintfac_right(k) - zdotintfac_right(k) ) )*phi_1d(k,jpp)

         integrandRsi_z_S(k) = phi_1d(k,ipp)*( -phix_1d(k,jpp)*( uintfac_right(k) - rdotintfac_right(k) ) - &
              reta_right(k)*CTJ/dt*phi_1d(k,jpp) )*rintfac_right(k)

         integrandRsi_u_S(k) = -phi_1d(k,jpp)*phi_1d(k,ipp)*zeta_right(k)*rintfac_right(k)

         integrandRsi_v_S(k) = phi_1d(k,jpp)*phi_1d(k,ipp)*reta_right(k)*rintfac_right(k)


         integrandRu_r_S(k) = ( phix_1d(k,ipp)*phix_1d(k,jpp) / ( reta_right(k)**2 + zeta_right(k)**2 ) - &
              reta_right(k)*phix_1d(k,ipp) / ( reta_right(k)**2 + zeta_right(k)**2 )**2 * 2.0d0*reta_right(k)*phix_1d(k,jpp) - &
              1.0d0/rintfac_right(k)**2 *phi_1d(k,jpp)*phi_1d(k,ipp) ) * &
              rintfac_right(k)*( reta_right(k)**2 + zeta_right(k)**2 )**0.5d0 + &

              ( reta_right(k)*phix_1d(k,ipp) / ( reta_right(k)**2 + zeta_right(k)**2 ) + phi_1d(k,ipp)/rintfac_right(k) )&
              *( phi_1d(k,jpp)*( reta_right(k)**2 + zeta_right(k)**2 )**0.5d0 + &
              rintfac_right(k) / ( reta_right(k)**2 + zeta_right(k)**2 )**0.5d0 *reta_right(k)*phix_1d(k,jpp) )

         integrandRu_z_S(k) = -reta_right(k)*phix_1d(k,ipp)*( reta_right(k)**2 + zeta_right(k)**2 )**(-1.5d0) *&
              2.0d0*zeta_right(k)*phix_1d(k,jpp)*rintfac_right(k) + &

              ( reta_right(k)*phix_1d(k,ipp) / ( reta_right(k)**2 + zeta_right(k)**2 ) + phi_1d(k,ipp)/rintfac_right(k) ) *&
              rintfac_right(k) / ( reta_right(k)**2 + zeta_right(k)**2 )**0.5d0 *zeta_right(k)*phix_1d(k,jpp)


         integrandRv_r_S(k) = zeta_right(k)*phix_1d(k,ipp)*&
              ( -( reta_right(k)**2 + zeta_right(k)**2 )**(-1.5d0) *reta_right(k)*phix_1d(k,jpp)*rintfac_right(k) + &
              ( reta_right(k)**2 + zeta_right(k)**2 )**(-0.5d0) *phi_1d(k,jpp) )

         integrandRv_z_S(k) = phix_1d(k,ipp)*phix_1d(k,jpp) / ( reta_right(k)**2 + zeta_right(k)**2 )**0.5d0 *rintfac_right(k) - &
              zeta_right(k)**2 *phix_1d(k,ipp)*phix_1d(k,jpp) / ( reta_right(k)**2 + zeta_right(k)**2 )**1.5d0 *rintfac_right(k)


      end do
      sj(i,j,NNz,NNr) = sj(i,j,NNz,NNr) - M1*gaussian_quadrature_1d(integrandReta_r_S)
      sj(i,j,NNz,NNz) = sj(i,j,NNz,NNz) - M1*gaussian_quadrature_1d(integrandReta_z_S)

      sj(i,j,NNr,NNr) = gaussian_quadrature_1d(integrandRsi_r_S)     !directly replace Rsi_V with Rsi_S, viz KBC
      sj(i,j,NNr,NNz) = gaussian_quadrature_1d(integrandRsi_z_S)
      sj(i,j,NNr,NNu) = gaussian_quadrature_1d(integrandRsi_u_S)
      sj(i,j,NNr,NNv) = gaussian_quadrature_1d(integrandRsi_v_S)
      
      sj(i,j,NNu,NNr) = sj(i,j,NNu,NNr) + gaussian_quadrature_1d(integrandRu_r_S)
      sj(i,j,NNu,NNz) = sj(i,j,NNu,NNz) + gaussian_quadrature_1d(integrandRu_z_S)

      sj(i,j,NNv,NNr) = sj(i,j,NNv,NNr) + gaussian_quadrature_1d(integrandRv_r_S)
      sj(i,j,NNv,NNz) = sj(i,j,NNv,NNz) + gaussian_quadrature_1d(integrandRv_z_S)
   
   else
   sj(i,j,NNr,:) = 0.0d0        !d Rsi/ d xj = 0.0d0 other than j = 3,6,9

   end if
end if

   !**********************************************************************************************************************


 end subroutine SI_in_sj



subroutine Dirichlet_BC
implicit none


        ! ! p is the reference pressure    
        ! j = NOPP(1+NNX)+Np
        ! Jac(j,:) = 0.0d0
        ! Jac(j,(iBW+1)/2) = 1.0d0
        ! Res(j) = 0.0d0
                                                  



if(timestep.eq.0) then

        !nodes at the lower boundary
        do i = 1, NNX, 1
           do j = NOPP(i), NOPP(i)+3       !the location of zi in sol(:)
              if(j.eq.NOPP(i)) cycle
              Jac(j,:) = 0.0d0
              Jac(j,(iBW+1)/2) = 1.0d0
              Res(j) = 0.0d0
           end do
        end do    !end loop for i

        !nodes at the left
        do i = 1, NTN-NNX+1, NNX
           do j = NOPP(i), NOPP(i)+3       !the location of zi in sol(:)
              if(j.eq.NOPP(i)+1) cycle
              Jac(j,:) = 0.0d0
              Jac(j,(iBW+1)/2) = 1.0d0
              Res(j) = 0.0d0
           end do
        end do    !end loop for i

        !nodes at the upper boundary
        do i = NTN-NNX+1, NTN, 1
           do j = NOPP(i), NOPP(i)+3       !the location of zi in sol(:)
              if(j.eq.NOPP(i)) cycle
              Jac(j,:) = 0.0d0
              Jac(j,(iBW+1)/2) = 1.0d0
              Res(j) = 0.0d0
           end do
        end do    !end loop for i

        !nodes at the right
        do i = NNX, NTN, NNX

           j = NOPP(i)        !the location of Rsi(i) in Res
           Jac(j,:) = 0.0d0
           Jac(j, bgbl(j,j) ) = 1.0d0    !dRsi/dri
           Jac(j, bgbl(j,j+1)  ) = -0.1d0*3.14d0/H*sin(zcoordinate(i)*3.14d0/H)     !dRsi/dzi
           Res(j) = rcoordinate(i) - R + 0.1d0*cos( zcoordinate(i)*3.14d0/H )

           do j = NOPP(i)+2, NOPP(i)+3       !the location of zi in sol(:)
              if(j.eq.NOPP(i)+1) cycle
              Jac(j,:) = 0.0d0
              Jac(j,(iBW+1)/2) = 1.0d0
              Res(j) = 0.0d0
           end do
        end do    !end loop for i




     else

                                                                      

        !nodes at the lower boundary
        do i = 1, NNX, 1
           j = NOPP(i)+Nz       !the location of zi in sol(:)
              Jac(j,:) = 0.0d0
              Jac(j,(iBW+1)/2) = 1.0d0
              Res(j) = 0.0d0

           j = NOPP(i)+Nv        !the location of vi in sol(:)
              Jac(j,:) = 0.0d0
              Jac(j,(iBW+1)/2) = 1.0d0
              Res(j) = 0.0d0
        end do    !end loop for i

        !nodes at the left
        do i = 1, NTN-NNX+1, NNX
           j = NOPP(i)+Nr       !the location of ri in sol(:)
              Jac(j,:) = 0.0d0
              Jac(j,(iBW+1)/2) = 1.0d0
              Res(j) = 0.0d0

           j = NOPP(i)+Nu        !the location of ui in sol(:)
              Jac(j,:) = 0.0d0
              Jac(j,(iBW+1)/2) = 1.0d0
              Res(j) = 0.0d0
        end do    !end loop for i

        !nodes at the upper boundary
        do i = NTN-NNX+1, NTN, 1
           j = NOPP(i)+Nz       !the location of zi in sol(:)
              Jac(j,:) = 0.0d0
              Jac(j,(iBW+1)/2) = 1.0d0
              Res(j) = 0.0d0

           j = NOPP(i)+Nv        !the location of vi in sol(:)
              Jac(j,:) = 0.0d0
              Jac(j,(iBW+1)/2) = 1.0d0
              Res(j) = 0.0d0
        end do    !end loop for i

        ! !nodes at the right
        ! do i = NNX, NTN, NNX
        ! end do    !end loop for i

     end if



      end subroutine Dirichlet_BC


  
  subroutine split_sol
    implicit none


    do i = 1, NTN, 1
       rcoordinate(i) = sol( NOPP(i) + Nr ) 
       zcoordinate(i) = sol( NOPP(i) + Nz ) 
       usol(i) = sol( NOPP(i) + Nu ) 
       vsol(i) = sol( NOPP(i) + Nv ) 
       if ( MDF(i) .gt. Np )     psol(i) = sol( NOPP(i) + Np ) 
    end do

       !interpolate p(:)
       do i = 1, 2*NEY + 1, 2
          do j = 2, NNX-1, 2
             psol( j + NNX*(i-1) ) = 0.5d0*( psol( j + NNX*(i-1) - 1 ) + psol( j + NNX*(i-1) + 1 ) )
          end do
       end do
       do i = 2, 2*NEY , 2
          do j = 1, NNX, 1
             psol( j + NNX*(i-1) ) = 0.5d0*( psol( j + NNX*(i-1) - NNX ) + psol( j + NNX*(i-1) + NNX ) )
          end do
       end do




  end subroutine split_sol





  double precision function f_size(si)
    implicit none

    real(kind=rk):: si
    f_size = 1.0d0

  end function f_size

  double precision function g_size(eta)
    implicit none

    real(kind=rk):: eta
    g_size = 1.0d0

  end function g_size











  double precision function phii(si, eta, i)
    implicit none
    real(kind=rk):: si, eta
    integer(kind=ik):: i

    select case(i)
    case(1)
       phii = ( 1.0d0 - 3.0d0*si + 2.0d0*si**2 )*( 1.0d0 - 3.0d0*eta + 2.0d0*eta**2 )
    case(2)
       phii = ( 4.0d0*si - 4.0d0*si**2 )*( 1.0d0 - 3.0d0*eta + 2.0d0*eta**2 )
    case(3)
       phii = ( -si + 2.0d0*si**2 )*( 1.0d0 - 3.0d0*eta + 2.0d0*eta**2 )
    case(4)
       phii = ( 1.0d0 - 3.0d0*si + 2.0d0*si**2 )*( 4.0d0*eta - 4.0d0*eta**2 )
    case(5)
       phii = ( 4.0d0*si - 4.0d0*si**2 )*( 4.0d0*eta - 4.0d0*eta**2 )
    case(6)
       phii = ( -si + 2.0d0*si**2 )*( 4.0d0*eta - 4.0d0*eta**2 )
    case(7)
       phii = ( 1.0d0 - 3.0d0*si + 2.0d0*si**2 )*( -eta + 2.0d0*eta**2 )
    case(8)
       phii = ( 4.0d0*si - 4.0d0*si**2 )*( -eta + 2.0d0*eta**2 )
    case(9)
       phii = ( -si + 2.0d0*si**2 )*( -eta + 2.0d0*eta**2 )
    case default
       write(*,*) 'error in i, in phii'
    end select

  end function phii


  double precision function phiisi(si, eta, i)
    implicit none
    real(kind=rk):: si, eta
    integer(kind=ik):: i

    select case(i)
    case(1)
       phiisi = ( -3.0d0 + 4.0d0*si )*( 1.0d0 - 3.0d0*eta + 2.0d0*eta**2 )
    case(2)
       phiisi = ( 4.0d0 - 8.0d0*si )*( 1.0d0 - 3.0d0*eta + 2.0d0*eta**2 )
    case(3)
       phiisi = ( -1.0d0 + 4.0d0*si )*( 1.0d0 - 3.0d0*eta + 2.0d0*eta**2 )
    case(4)
       phiisi = ( -3.0d0 + 4.0d0*si )*( 4.0d0*eta - 4.0d0*eta**2 )
    case(5)
       phiisi = ( 4.0d0 - 8.0d0*si )*( 4.0d0*eta - 4.0d0*eta**2 )
    case(6)
       phiisi = ( -1.0d0 + 4.0d0*si )*( 4.0d0*eta - 4.0d0*eta**2 )
    case(7)
       phiisi = ( -3.0d0 + 4.0d0*si )*( -eta + 2.0d0*eta**2 )
    case(8)
       phiisi = ( 4.0d0 - 8.0d0*si )*( -eta + 2.0d0*eta**2 )
    case(9)
       phiisi = ( -1.0d0 + 4.0d0*si )*( -eta + 2.0d0*eta**2 )
    case default
       write(*,*) 'error in i, in phiisi'
    end select

  end function phiisi


  double precision function phiieta(si, eta, i) 
    implicit none
    real(kind=rk):: si, eta
    integer(kind=ik):: i

    select case(i)
    case(1)
       phiieta = ( 1.0d0 - 3.0d0*si + 2.0d0*si**2 )*( -3.0d0 + 4.0d0*eta )
    case(2)
       phiieta = ( 4.0d0*si - 4.0d0*si**2 )*( -3.0d0 + 4.0d0*eta )
    case(3)
       phiieta = ( -si + 2.0d0*si**2 )*( -3.0d0 + 4.0d0*eta )
    case(4)
       phiieta = ( 1.0d0 - 3.0d0*si + 2.0d0*si**2 )*( 4.0d0 - 8.0d0*eta )
    case(5)
       phiieta = ( 4.0d0*si - 4.0d0*si**2 )*( 4.0d0 - 8.0d0*eta )
    case(6)
       phiieta = ( -si + 2.0d0*si**2 )*( 4.0d0 - 8.0d0*eta )
    case(7)
       phiieta = ( 1.0d0 - 3.0d0*si + 2.0d0*si**2 )*( -1.0d0 + 4.0d0*eta )
    case(8)
       phiieta = ( 4.0d0*si - 4.0d0*si**2 )*( -1.0d0 + 4.0d0*eta )
    case(9)
       phiieta = ( -si + 2.0d0*si**2 )*( -1.0d0 + 4.0d0*eta )
    case default
       write(*,*) 'error in i, in phiieta'
    end select

  end function phiieta





  double precision function psii(si, eta, i)
    implicit none
    real(kind=rk):: si, eta
    integer(kind=ik):: i

    select case(i)
    case(1)
       psii = (1.0d0-si)*(1.0d0-eta)
    case(2)
       psii = si*(1.0d0-eta)
    case(3)
       psii = (1.0d0-si)*eta
    case(4)
       psii = si*eta
    case default
       write(*,*) 'error in i, in psii'
    end select

  end function psii


  double precision function psiisi(eta, i)
    implicit none
    real(kind=rk):: eta
    integer(kind=ik):: i

    select case(i)
    case(1)
       psiisi = (-1.0d0)*(1.0d0-eta)
    case(2)
       psiisi = 1.0d0-eta
    case(3)
       psiisi = (-1.0d0)*eta
    case(4)
       psiisi = eta
    case default
       write(*,*) 'error in i, in psiisi'
    end select

  end function psiisi


  double precision function psiieta(si, i)
    implicit none
    real(kind=rk):: si
    integer(kind=ik):: i

    select case(i)
    case(1)
       psiieta = (1.0d0-si)*(-1.0d0)
    case(2)
       psiieta = si*(-1.0d0)
    case(3)
       psiieta = (1.0d0-si)
    case(4)
       psiieta = si
    case default
       write(*,*) 'error in i, in psiieta'
    end select

  end function psiieta


  double precision function phii_1d(x,i) 
    implicit none
    real(kind=rk):: x
    integer(kind=ik) :: i

    select case (i)
    case(1)
       phii_1d = 1.0d0 - 3.0d0*x + 2.0d0*x**2
    case(2)
       phii_1d = 4.0d0*( x - x**2 )
    case(3)
       phii_1d = -x + 2.0d0*x**2
    case default
       write(*,*) 'error in i, in phii_1d'
    end select

    return
  end function phii_1d



  double precision function phiix_1d(x,i)
    implicit none

    real(kind=rk):: x
    integer(kind=ik):: i
    select case(i)
    case(1)
       phiix_1d = -3.0d0 + 4.0d0*x
    case(2)
       phiix_1d = 4.0d0 - 8.0d0*x 
    case(3)
       phiix_1d = -1.0d0 + 4.0d0*x
    
    case default
       write(*,*) 'error in i, in phiix_1d'
    end select

  end function phiix_1d









double precision function gaussian_quadrature(f) 
  implicit none

  !gaussian quadrature integration in 0-1 with 3 mesh points.
  ! f(3,3)(integrand) needs to be defined:
  !use "do" loop to give value to f(3): eg, f(i) = a(i)**2 (This stands for f(x) = x**2 )

  integer(kind=ik):: i, j
  real(kind=rk):: f(3,3)
  real(kind=rk), parameter, dimension(3):: w = (/0.2777777777777777777777777777778d0,&
       0.44444444444444444444444444444444d0, 0.2777777777777777777777777777778d0/)

  gaussian_quadrature = 0.0d0
  do i = 1,3,1
     do j = 1,3,1
     gaussian_quadrature = gaussian_quadrature + w(i)*w(j)*f(i,j)
     end do
  end do

end function gaussian_quadrature

double precision function gaussian_quadrature_1d(f)
  implicit none

  !gaussian quadrature integration in 0-1 with 3 mesh points.
  ! f(3)(integrand) needs to be defined
  !use "do" loop to give value to f(3): eg, f(i) = a(i)**2 (This stands for f(x) = x**2 )

  integer(kind=ik):: i
  real(kind=rk):: f(3)
  real(kind=rk), parameter, dimension(3):: w = (/0.2777777777777777777777777777778d0,&
       0.44444444444444444444444444444444d0, 0.2777777777777777777777777777778d0/)

  gaussian_quadrature_1d = 0.0d0
  do i = 1,3,1
     gaussian_quadrature_1d = gaussian_quadrature_1d + w(i)*f(i)
  end do

  return
end function gaussian_quadrature_1d




subroutine NOP(eleN, locN, NEX)!, rowN, columnN, globalN)
    implicit none
    integer(kind=ik), intent(in) :: eleN, locN, NEX
    !integer(kind=ik), intent(out) :: rowN, columnN, globalN

    !calculate rowN & columnN
    if( mod( dble(eleN),dble(NEX) ) .eq. 0.0d0 ) then
       rowN = eleN/NEX              !no dble, rowN of elements
       columnN = NEX
    else
       rowN = eleN/NEX + 1          !no dble
       columnN = mod( dble(eleN),dble(NEX) )
    end if

    !calculate globalN
    globalN = 2*NNX*(rowN-1) + 2*(columnN-1)
    select case (locN)
    case(1)
       globalN = globalN + 1
    case(2)
       globalN = globalN + 2
    case(3)
       globalN = globalN + 3
    case(4)
       globalN = globalN + NNX + 1
    case(5)
       globalN = globalN + NNX + 2
    case(6)
       globalN = globalN + NNX + 3
    case(7)
       globalN = globalN + 2*NNX + 1
    case(8)
       globalN = globalN + 2*NNX + 2
    case(9)
       globalN = globalN + 2*NNX + 3
    end select

  end subroutine NOP





  integer function bgbl(k,l)  !change the Jac for FullGaussSolver to Jac for BandedSolver
    !(k,l) is the indicator for full Jac, kth row, lth column
    implicit none
    integer(kind=ik):: k,l 

    bgbl = l-k+(iBW+1)/2

  end function bgbl







subroutine check
implicit none

real(kind=rk):: sf_check(9,5), sj_check(9,9,5,5), check_matr(40,40)
integer(kind=ik):: jj,qq,x,y


  real(kind=rk):: prlocal(9), pzlocal(9), pulocal(9), pvlocal(9), pplocal(9)
  real(kind=rk):: prdotlocal(9), pzdotlocal(9), pudotlocal(9), pvdotlocal(9)






do jj = 1, 9, 1                 !j
   do qq = 1, 5, 1                       !q



! jj = 9
! qq = 1

      if ( ( (jj.eq.2) .or. (jj.eq.4) .or. (jj.eq.5) .or. (jj.eq.6) .or. (jj.eq.8) ) .and. ( qq .eq. 5 ) ) cycle
  
      y = NOPP( globalNM(m,jj) ) + qq-1

      sol(y) = sol(y) + TOL

      if (timestep.le.5) then
         soldot(y) = ( sol(y) - solp(y) )/dt
      else
         soldot(y) = 2.0d0*( sol(y) - solp(y) )/dt - soldotp(y)
      end if



prlocal(:) = rlocal(:)
pzlocal(:) = zlocal(:)
pulocal(:) = ulocal(:)
pvlocal(:) = vlocal(:)
pplocal(:) = plocal(:)
prdotlocal(:) = rdotlocal(:)
pzdotlocal(:) = zdotlocal(:)
pudotlocal(:) = udotlocal(:)
pvdotlocal(:) = vdotlocal(:)
      



      call values_in_an_element



      do i = 1, 9, 1            !i is the i in the residual Res(i)
      !i = 3

    do k = 1, 3, 1
       do l = 1, 3, 1

          !Aterm(k,l,i)
          Aterm(k,l) = ( zeta(k,l)**2 + reta(k,l)**2 )*phisi(k,l,i) - &
               ( zeta(k,l)*zsi(k,l) + reta(k,l)*rsi(k,l) )*phieta(k,l,i)
          Bterm(k,l) = -( zsi(k,l)*zeta(k,l) + rsi(k,l)*reta(k,l) )*phisi(k,l,i) &
               + ( zsi(k,l)**2 + rsi(k,l)**2 )*phieta(k,l,i)

          integrandRsi_V(k,l) = ( s_orth(k,l) + epss )*Aterm(k,l)/Jp(k,l) - &
               eps1*phisi(k,l,i)*f_size( gausspoint(k) )*log( rsi(k,l)**2 + zsi(k,l)**2 )

          integrandReta_V(k,l) = ( 1.0d0/s_orth(k,l) + epss )*Bterm(k,l)/Jp(k,l) - &
               eps2*phieta(k,l,i)*g_size( gausspoint(l) )*log( reta(k,l)**2 + zeta(k,l)**2 )


          integrandRu_V(k,l) = ( phi(k,l,i)*( udotintfac(k,l) + ( uintfac(k,l) - rdotintfac(k,l) )*urintfac(k,l) +  &
               ( vintfac(k,l) - zdotintfac(k,l) )*uzintfac(k,l) )  - &
               Kdi*pintfac(k,l)*Oh*( phir(k,l,i) + phi(k,l,i)/rintfac(k,l) ) + &
               Oh*( 2.0d0*urintfac(k,l)*phir(k,l,i) + ( uzintfac(k,l) + vrintfac(k,l) )*phiz(k,l,i) + &
               phi(k,l,i)*2.0d0/rintfac(k,l)**2 *uintfac(k,l) ) )  *rintfac(k,l)*abs(Jp(k,l))

          integrandRv_V(k,l) = ( phi(k,l,i)*( vdotintfac(k,l) + ( uintfac(k,l) - rdotintfac(k,l) )*vrintfac(k,l) + &
               ( vintfac(k,l) - zdotintfac(k,l) )*vzintfac(k,l) + Grav ) - Kdi*pintfac(k,l)*Oh*phiz(k,l,i) + &
               Oh*( ( uzintfac(k,l) + vrintfac(k,l) ) *phir(k,l,i) + 2.0d0*vzintfac(k,l)*phiz(k,l,i) ) ) &
               *rintfac(k,l)*abs(Jp(k,l))

          integrandRp(k,l) = psi(k,l,i)* ( urintfac(k,l) + uintfac(k,l)/rintfac(k,l) + vzintfac(k,l) ) &
               *rintfac(k,l)*abs(Jp(k,l))
       end do
    end do


    sf_check(i,NNr) = gaussian_quadrature(integrandRsi_V)
    sf_check(i,NNz) = gaussian_quadrature(integrandReta_V)
    sf_check(i,NNu) = gaussian_quadrature(integrandRu_V)
    sf_check(i,NNv) = gaussian_quadrature(integrandRv_V)
    sf_check(i,NNp) = gaussian_quadrature(integrandRp)    !sf_check( (2,4,5,6,8) ,5) = 0.0d0


    !*******************************************adding SI to sf_check********************************************************

    if( (rowNM(m).eq.1) .and. ( (i.eq.1) .or. (i.eq.2) .or. (i.eq.3) ) )  then
       do k = 1, 3, 1    !three gausspoints
          ipp = i  !phix_1d(k,ipp)
          integrandRsi_S(k) = phix_1d(k,ipp) * f_size( gausspoint(k) ) * log( rsi_down(k)**2 + zsi_down(k)**2 )
       end do
       sf_check(i,NNr) = sf_check(i,NNr)  -  M1*gaussian_quadrature_1d(integrandRsi_S)
    end if

    if( (rowNM(m).eq.NEY) .and. ( (i.eq.7) .or. (i.eq.8) .or. (i.eq.9) ) )  then
       do k = 1, 3, 1    !three gausspoints
          ipp = i - 6  !phix_1d(k,ipp)
          integrandRsi_S(k) = phix_1d(k,ipp) * f_size( gausspoint(k) ) * log( rsi_up(k)**2 + zsi_up(k)**2 )
       end do
       sf_check(i,NNr) = sf_check(i,NNr)  -  M1*gaussian_quadrature_1d(integrandRsi_S)
    end if

    if( (columnNM(m).eq.1) .and. ( (i.eq.1) .or. (i.eq.4) .or. (i.eq.7) ) )  then
       do k = 1, 3, 1    !three gausspoints
          ipp = i/3 + 1  !phix_1d(k,ipp)
          integrandReta_S(k) = phix_1d(k,ipp) * g_size( gausspoint(k) ) * log( reta_left(k)**2 + zeta_left(k)**2 )
       end do
       sf_check(i,NNz) = sf_check(i,NNz)  -  M2*gaussian_quadrature_1d(integrandReta_S)
    end if

    if( (columnNM(m).eq.NEX) .and. ( (i.eq.3) .or. (i.eq.6) .or. (i.eq.9) ) )  then
       do k = 1, 3, 1    !three gausspoints
          ipp = i/3  !phix_1d(k,ipp)
          integrandReta_S(k) = phix_1d(k,ipp) * g_size( gausspoint(k) ) * log( reta_right(k)**2 + zeta_right(k)**2 )


          integrandRsi_S(k) = phi_1d(k,ipp)*( -zeta_right(k)*( uintfac_right(k) - rdotintfac_right(k) ) + &
               reta_right(k)*( vintfac_right(k) - zdotintfac_right(k) ) )*rintfac_right(k)

          integrandRu_S(k) = ( reta_right(k)*phix_1d(k,ipp) / ( reta_right(k)**2 + zeta_right(k)**2 ) + &
               phi_1d(k,ipp)/rintfac_right(k) )*rintfac_right(k)*( reta_right(k)**2 + zeta_right(k)**2 )**0.5d0

          integrandRv_S(k) = zeta_right(k)*phix_1d(k,ipp) / ( reta_right(k)**2 + zeta_right(k)**2 )**0.5d0 &
               *rintfac_right(k)

       end do
       sf_check(i,NNz) = sf_check(i,NNz)  -  M2*gaussian_quadrature_1d(integrandReta_S)

       sf_check(i,NNr) = gaussian_quadrature_1d(integrandRsi_S)          !directly replace Rsi_V with Rsi_S, viz KBC
       sf_check(i,NNu) = sf_check(i,NNu)  + gaussian_quadrature_1d(integrandRu_S)
       sf_check(i,NNv) = sf_check(i,NNv)  + gaussian_quadrature_1d(integrandRv_S)
    end if

    
    
    do p = 1, 5, 1
    !p = 1


       if ( ( (i.eq.2) .or. (i.eq.4) .or. (i.eq.5) .or. (i.eq.6) .or. (i.eq.8) ) .and. ( p .eq. 5 ) ) cycle

       sj_check(i,jj,p,qq) = ( sf_check(i,p) - sf(i,p) )/TOL
       check_matr( LNOPP(i)+p-1, LNOPP(jj)+qq-1 ) = sj_check(i,jj,p,qq) - sj(i,jj,p,qq)

       if( abs( sj_check(i,jj,p,qq) - sj(i,jj,p,qq) ) .gt. 0.5d-3 ) then
          ! write(*,*) 'error in Jac', ',p=', p, ',qq=', qq

             write(*,*) 'sj_check=', sj_check(i,jj,p,qq), 'sj=', sj(i,jj,p,qq)
             write(*,*) 'sf_check=' , sf_check(i,p), 'sf =', sf(i,p)
             write(*,*) time, m,i,jj,p,qq
             !pause
       end if
       
       ! if(m.eq.2.and.i.eq.9.and.p.eq.1.and.jj.eq.9.and.qq.eq.5) then
       !    write(*,*) 'sj_check=', sj_check(i,jj,p,qq), 'sj=', sj(i,jj,p,qq)
       !    write(*,*) 'sf_check=' , sf_check(i,p), 'sf =', sf(i,p)
       !    pause
       ! end if




    end do        !end loop for p


      end do       !end loop for i, R(r,z)i 

      
      
      y = NOPP( globalNM(m,jj) ) + qq-1
      sol(y) = sol(y) - TOL
      if (timestep.le.5) then
         soldot(y) = ( sol(y) - solp(y) )/dt
      else
         soldot(y) = 2.0d0*( sol(y) - solp(y) )/dt - soldotp(y)
      end if

      



      
    end do !end loop for qq
end do              !end loop for jj







! open(unit = 10, file = 'check_matr.dat', status = 'replace' )
!   do i = 1, 40, 1
!     do jj = 1, 40, 1
!         write( 10, '(40es14.7)', advance = 'no' ) check_matr(i,jj)
!      end do
!      write(10, '(A)') 
!   end do
!   close(10)
! write(*,*) 'done'


end subroutine check









end module NOP_mod

